'''
Name        : _Naive_Approach_Main.py
Version     : 1.0b
Author      : Alpaca (Waddah & Jack)

Input: None
Intermediates:
    All other functions in this module
Output: 0 or 1 (successful or failed run)

Details:
** The ultimate purpose for this is to find minimize RMSE for each cluster.
'''

'''
This function will go through the step of trying to investigate the right model for a Naive Appraoch
It will evaluate the RMSE for all the movies of a cluster (between actual and predicted ratings). 
It will choose a different model and calculate RMSE until it is below a certain threshold, then it will stop search
For now, this will be based on Movie Clustered based on Genres, Run Time and Year features. 

The next step is to integrate with user-clustered data. 
'''

import sys                 # to include current direction in the working directory
import os

import statistics
import numpy as np
np.set_printoptions(threshold=np.inf)    # to print entire output of numpy array

# import math
from math import sqrt

import time

import itertools

#================importing other functions that generate

# import ProbeUserID as probe
from sklearn.metrics import mean_squared_error

from Mine_Cluster_Movie_IDs import *
from Mine_Cluster_Users_IDs import *

from Mine_Dict_Movie_Ratings import *
# from Mine_Dict_User_Ratings import *

from GenerateSingleMovieRatingStats import *
from GenerateSingleUserRatingStats import *

# from RMSE_Ratings import *

from ProbeUserIDs import *

from joblib import Parallel, delayed
import multiprocessing as mp

#================================================================================================================================================
def Mine_Dict_User_Ratings(DesiredUserID, InEpoch=True, UserMovieData = {}):
    '''
    #file name CustomerIDDict.csv generated by ___________________________________
    # File format is:
    UserID: MovieID 1 | Date 1 | Rating 1, MovieID 2 | Date 2 | Rating 2, ..., \n
    Each User Information is on a single currentLine.
    '''
    MovieRatings = []
    MovieIDs = []    # Can be used to create keys, but not the focus right now
    MovieDates = []

    # Use "in" function to search since it is the fastest way to search
    if DesiredUserID in UserMovieData:
        DesiredUserMovieData = UserMovieData[DesiredUserID]
        # print('User Ratings Found')
        # print('For User ID:', DesiredUserID, ', the movie ratings are: (MovieID|YYYY-MM-DD|Rating): \n', DesiredUserMovieData)

        AllMovieData = DesiredUserMovieData.split(',')
        #print('All Movie data Here Split into an Array: \n',AllMovieData)

        for CurrentMovie in AllMovieData:
            #(Movie ID|Date|Rating)
            CurrentMovieData = CurrentMovie.split('|')

            MovieRatings.append(int(CurrentMovieData[2]))
            CurrentMovieDate = CurrentMovieData[1]

            if InEpoch:
                DateRatedFormat = '%Y-%m-%d'
                DateRatedEpoch = int(time.mktime(time.strptime(CurrentMovieDate, DateRatedFormat)))
                MovieDates.append(DateRatedEpoch)
            else:
                MovieDates.append(CurrentMovieDate)


    else:
        print('User Ratings Not Found')

    return DesiredUserID, MovieRatings, MovieDates



#================================================================================================================================================
def main():
    # Next step is to look through all clusters?
    # Note: first cluster is cluster #0

    # Desired Movie Cluster Number
    DesiredMovieClusterNumber = 10
    # Desired UserCluster Number
    DesiredUserClusterNumber = 9



    # Starting a timer to evaluate how long the process lasts
    StartTime = time.time()

    #
    # print('--------------------Movie Cluster Modeling *Started*--------------------')
    # KnownMovieRatings = np.array([])
    # PredictedMovieRatings = np.array([])
    # KnownMovieRatingsCount = np.array([])
    #
    # # # 1.1 Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    # ClusterMovieIDs = np.array(Mine_Cluster_Movie_IDs(DesiredClusterNumber=1))
    # print('There are', len(ClusterMovieIDs), 'users in Movie Cluster #', DesiredMovieClusterNumber)
    # print('Finding the ratings for each user of each movie in the movie cluster...IN PROGRESS.')
    # for CurrentMovieID in ClusterMovieIDs:
    #     # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    #     # UserRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
    #     CurrentMovieRatings = Mine_Dict_Movie_Ratings(CurrentMovieID, InEpoch=True)
    #
    #     # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
    #     KnownMovieRatings = np.append(KnownMovieRatings, CurrentMovieRatings[1])
    #
    #     # # Add up the number of users rating the current movie
    #     CurrentMovieRatingsCount = len(CurrentMovieRatings[1])
    #     # KnownMovieRatingsCount = np.append(KnownMovieRatingsCount, CurrentMovieRatingsCount)
    #
    #
    #     # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
    #     # for now that will be the simplest appraoch).
    #     # This average reading will be the give for all users regardless.
    #     # Movie Stats are: MovieID, UserMeanRating, UserMaxRating, UserMinRating, UserStdDev
    #     CurrentMovieStats = GenerateSingleMovieRatingStats(CurrentMovieID)
    #
    #     # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
    #     # Repeating the same values for all ratings
    #     PredictedMovieRatings = np.append(PredictedMovieRatings, np.repeat(CurrentMovieStats[1],CurrentMovieRatingsCount))  # CurrentMovieMean = CurrentMovieStats[1]
    #
    #
    # # print('Known Movie Ratings: ', KnownMovieRatings)
    # # print('Predicted Movie Ratings: ', PredictedMovieRatings)
    # # print('Number of Known Ratings per movie:', KnownMovieRatingsCount)
    #
    #
    #
    # # 5. Calculate the RMSE for each movie, from RMSE(KNOWN Rating, Predicted Rating).
    # CurrentMovieClusterRMSE = RMSE_Ratings(KnownMovieRatings,PredictedMovieRatings)
    # print('RMSE for Movie Cluster #', DesiredMovieClusterNumber, 'is: ', CurrentMovieClusterRMSE)
    # print('Finding the ratings for each movies of each user in the user cluster...IN PROGRESS.')
    #
    # ## 6. Make a choice about whether to accept that rating or not.
    # # return 0
    #
    # # Ending the process. Ending Timer
    # ElapsedTime = time.time() - StartTime
    # print('Time elapsed: ', ElapsedTime, ' seconds.')
    # print('--------------------Movie Cluster Modeling *Finished*--------------------')
    #

















    print('--------------------User Cluster Modeling *Started*--------------------')
    KnownUserRatings = np.array([])
    PredictedUserRatings = np.array([])
    KnownUserRatingsCount = np.array([])

    # 1.2 Mining User IDs in a given cluster label generated from UserIDclusters.csv
    # 1.1 Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    ClusterUserIDs = np.array(Mine_Cluster_User_IDs(DesiredUserClusterNumber))

    print('There are', len(ClusterUserIDs), 'users in Cluster #', DesiredUserClusterNumber)

    count = 0

    UserRatings = []
    MovieIDs = []    # Can be used to create keys, but not the focus right now
    MovieDates = []

    fileName = '../data/customerIDDict.csv'
    # open the file
    FileHeader = open(fileName, 'r')

    # Generating Keys and data
    UserMovieData = {}
    with open(fileName) as fileHeader:
        for currentLine in fileHeader:
            # userID = userID: movie data is (Movie ID|Date|Rating)
            (userID, movieData) = currentLine.split(':')
            UserMovieData[int(userID)] = movieData

    # Parallel processing
    print('--------------------Parallel Processing *Started*--------------------')
    #
    # Figuring out the number of cores in this PC
    num_cores = mp.cpu_count()
    print('This computer has', num_cores, 'cores.')

    poolProcesses = mp.Pool(processes=num_cores)
    #
    # results = [poolProcesses.apply(Mine_Dict_User_Ratings, args=(CurrentUserID, True, UserMovieData)) for CurrentUserID in ClusterUserIDs]
    # print(results)

    # results = [poolProcesses.map(Mine_Dict_User_Ratings(CurrentUserID, True, UserMovieData)) for CurrentUserID in ClusterUserIDs]
    # print(results)

    # Using asynchronous parallel processing
    results = [poolProcesses.apply_async(Mine_Dict_User_Ratings, args=(CurrentUserID, True, UserMovieData)) for CurrentUserID in ClusterUserIDs]
    AllUserRatingsData = [p.get() for p in results]
    print('Parallel processing output', AllUserRatingsData)
    print('--------------------Parallel Processing *Ended*--------------------')


    for CurrentUserID in ClusterUserIDs:
        # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
        # UserRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
        count = count + 1
        CurrentUserRatings = Mine_Dict_User_Ratings(CurrentUserID, True, UserMovieData)
        UserRatings = CurrentUserRatings[1]
        # Evaluating all the movie statistics

        UserMeanRating = np.nanmean(UserRatings)
        UserMaxRating = np.nanargmax(UserRatings)
        UserMinRating = np.nanargmin(UserRatings)
        UserStdDev = np.nanstd(UserRatings)

        ElapsedTime = time.time() - StartTime
        print(count, ': Current User ID#', CurrentUserID, '\t Time elapsed: ', ElapsedTime, ' seconds.')

        # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
        KnownUserRatings = np.append(KnownUserRatings, UserRatings)

        ## Add up the number of users rating the current movie. This feature might be used to figure out how to
        ## distribute the load among cores.
        CurrentUserRatingsCount = len(UserRatings)
        # KnownUserRatingsCount = np.append(KnownUserRatingsCount, CurrentUserRatingsCount)

        # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
        # for now that will be the simplest approach).
        # This average reading will be the give for all users regardless.
        # Movie Stats are: MovieID, UserMeanRating, UserMaxRating, UserMinRating, UserStdDev


        # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
        # Repeating the same values for all ratings
        PredictedUserRatings = np.append(PredictedUserRatings, np.repeat(UserRatings,
                                                                         CurrentUserRatingsCount))  # CurrentMovieMean = CurrentMovieStats[1]


    # print('Known Movie Ratings: ', KnownMovieRatings)
    # print('Predicted Movie Ratings: ', PredictedMovieRatings)
    # print('Number of Known Ratings per movie:', KnownMovieRatingsCount)



    # 5. Calculate the RMSE for each movie, from RMSE(KNOWN Rating, Predicted Rating).

    CurrentUserClusterRMSE = sqrt(mean_squared_error(KnownUserRatings,PredictedUserRatings))
    print('RMSE for User Cluster #', DesiredUserClusterNumber, 'is: ', CurrentUserClusterRMSE)

    # 6. Make a choice about whether to accept that rating or not.
    # return 0

    # 7. Closing the dictionary file
    FileHeader.close()

    # Ending the process. Ending Timer
    ElapsedTime = time.time() - StartTime
    print('Time elapsed: ', ElapsedTime, ' seconds.')
    print('--------------------Finishing the process--------------------')
    #
















if __name__ == "__main__":
    main()


