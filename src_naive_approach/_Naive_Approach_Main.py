'''
Name        : _Naive_Approach_Main.py
Version     : 1.0b
Author      : Alpaca (Waddah & Jack)

Input: None
Intermediates:
    All other functions in this module
Output: 0 or 1 (successful or failed run)

Details:
** The ultimate purpose for this is to find minimize RMSE for each cluster.
'''

'''
This function will go through the step of trying to investigate the right model for a Naive Appraoch
It will evaluate the RMSE for all the movies of a cluster (between actual and predicted ratings). 
It will choose a different model and calculate RMSE until it is below a certain threshold, then it will stop search
For now, this will be based on Movie Clustered based on Genres, Run Time and Year features. 

The next step is to integrate with user-clustered data. 
'''

import sys                 # to include current direction in the working directory
import os

import statistics
import numpy as np
np.set_printoptions(threshold=np.inf)    # to print entire output of numpy array


import math
import time

import itertools

#================importing other functions that generate

# import ProbeUserID as probe
from sklearn.metrics import mean_squared_error

from Mine_Cluster_Movie_IDs import *
from Mine_Cluster_Users_IDs import *

from Mine_Dict_Movie_Ratings import *
from Mine_Dict_User_Ratings import *

from GenerateSingleMovieRatingStats import *
from GenerateSingleUserRatingStats import *

from RMSE_Ratings import *

from ProbeUserIDs import *

from joblib import Parallel, delayed
import multiprocessing as mp


#================================================================================================================================================
def main():
    # Next step is to look through all clusters?
    # Note: first cluster is cluster #0

    # Desired Movie Cluster Number
    DesiredMovieClusterNumber = 10
    # Desired UserCluster Number
    DesiredUserClusterNumber = 9

    # Figuring out the number of cores in this PC
    num_cores = mp.cpu_count()
    print('This computer has', num_cores, 'cores.')

    # Starting a timer to evaluate how long the process lasts
    StartTime = time.time()


    print('--------------------Movie Cluster Modeling *Started*--------------------')
    KnownMovieRatings = np.array([])
    PredictedMovieRatings = np.array([])
    KnownMovieRatingsCount = np.array([])

    # # 1.1 Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    ClusterMovieIDs = np.array(Mine_Cluster_Movie_IDs(DesiredClusterNumber=1))
    print('There are', len(ClusterMovieIDs), 'users in Movie Cluster #', DesiredMovieClusterNumber)
    print('Finding the ratings for each user of each movie in the movie cluster...IN PROGRESS.')
    for CurrentMovieID in ClusterMovieIDs:
        # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
        # MovieRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
        CurrentMovieRatings = Mine_Dict_Movie_Ratings(CurrentMovieID, InEpoch=True)

        # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
        KnownMovieRatings = np.append(KnownMovieRatings, CurrentMovieRatings[1])

        # # Add up the number of users rating the current movie
        CurrentMovieRatingsCount = len(CurrentMovieRatings[1])
        # KnownMovieRatingsCount = np.append(KnownMovieRatingsCount, CurrentMovieRatingsCount)


        # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
        # for now that will be the simplest appraoch).
        # This average reading will be the give for all users regardless.
        # Movie Stats are: MovieID, MeanRating, MaxRating, MinRating, MovieStdDev
        CurrentMovieStats = GenerateSingleMovieRatingStats(CurrentMovieID)

        # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
        # Repeating the same values for all ratings
        PredictedMovieRatings = np.append(PredictedMovieRatings, np.repeat(CurrentMovieStats[1],CurrentMovieRatingsCount))  # CurrentMovieMean = CurrentMovieStats[1]


    # print('Known Movie Ratings: ', KnownMovieRatings)
    # print('Predicted Movie Ratings: ', PredictedMovieRatings)
    # print('Number of Known Ratings per movie:', KnownMovieRatingsCount)



    # 5. Calculate the RMSE for each movie, from RMSE(KNOWN Rating, Predicted Rating).
    CurrentMovieClusterRMSE = RMSE_Ratings(KnownMovieRatings,PredictedMovieRatings)
    print('RMSE for Movie Cluster #', DesiredMovieClusterNumber, 'is: ', CurrentMovieClusterRMSE)
    print('Finding the ratings for each movies of each user in the user cluster...IN PROGRESS.')

    # ## 6. Make a choice about whether to accept that rating or not.
    # # return 0
    #
    # # Ending the process. Ending Timer
    # ElapsedTime = time.time() - StartTime
    # print('Time elapsed: ', ElapsedTime, ' seconds.')
    # print('--------------------Movie Cluster Modeling *Finished*--------------------')
    #

    print('--------------------User Cluster Modeling *Started*--------------------')
    KnownUserRatings = np.array([])
    PredictedUserRatings = np.array([])
    KnownUserRatingsCount = np.array([])

    # 1.2 Mining User IDs in a given cluster label generated from UserIDclusters.csv
    # 1.1 Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    ClusterUserIDs = np.array(Mine_Cluster_User_IDs(DesiredUserClusterNumber))

    print('There are', len(ClusterUserIDs), 'users in Cluster #', DesiredUserClusterNumber)

    count = 0
    for CurrentUserID in ClusterUserIDs:
        # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
        # MovieRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
        count = count + 1

        CurrentUserRatings = Mine_Dict_User_Ratings(CurrentUserID, InEpoch=True)

        ElapsedTime = time.time() - StartTime
        print(count, ': Current User ID#', CurrentUserID, '\t Time elapsed: ', ElapsedTime, ' seconds.')

        # print('User #', CurrentUserID, ' current details are are:' , CurrentUserRatings, '\n')

        # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
        KnownUserRatings = np.append(KnownUserRatings, CurrentUserRatings[1])

        ## Add up the number of users rating the current movie. This feature might be used to figure out how to
        ## distribute the load among cores.
        CurrentUserRatingsCount = len(CurrentUserRatings[1])
        # KnownUserRatingsCount = np.append(KnownUserRatingsCount, CurrentUserRatingsCount)

        # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
        # for now that will be the simplest approach).
        # This average reading will be the give for all users regardless.
        # Movie Stats are: MovieID, MeanRating, MaxRating, MinRating, MovieStdDev
        CurrentUserStats = GenerateSingleUserRatingStats(CurrentUserID)

        # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
        # Repeating the same values for all ratings
        PredictedUserRatings = np.append(PredictedUserRatings, np.repeat(CurrentUserStats[1],
                                                                         CurrentUserRatingsCount))  # CurrentMovieMean = CurrentMovieStats[1]


    # print('Known Movie Ratings: ', KnownMovieRatings)
    # print('Predicted Movie Ratings: ', PredictedMovieRatings)
    # print('Number of Known Ratings per movie:', KnownMovieRatingsCount)



    # 5. Calculate the RMSE for each movie, from RMSE(KNOWN Rating, Predicted Rating).
    CurrentUserClusterRMSE = RMSE_Ratings(KnownUserRatings,PredictedUserRatings)
    print('RMSE for User Cluster #', DesiredUserClusterNumber, 'is: ', CurrentUserClusterRMSE)

    # 6. Make a choice about whether to accept that rating or not.
    # return 0


    # Ending the process. Ending Timer
    ElapsedTime = time.time() - StartTime
    print('Time elapsed: ', ElapsedTime, ' seconds.')
    print('--------------------Finishing the process--------------------')
    #


if __name__ == "__main__":
    main()






#=======================================================================================================================
''' Trash lines of code


# #================================================================================================================================================
# def ProbeUserIDs(MovieID):
#
#     fileHeader = open("../data/probe.txt", 'r')
#     AllLines = fileHeader.readlines()
#     z = 0
#     for currentLine in AllLines:
#         if ':' in currentLine:
#             a = ''
#             for x in currentLine:
#                 if x != ':':
#                     a = a + x
#                 else:
#                     break
#                 if MovieID == a:
#                     w = 1
#                     userIDs = []
#                     while w > 0 :
#                         if ':' not in AllLines[z+w]:
#                             newline = AllLines[z+w].strip('\n')
#                             userIDs.append(newline)
#                             w = w + 1
#                         else:
#                             continue
#         z = z + 1
#
#         return userIDs

    KnownMovieRatings = []
    PredictedMovieRatings = []
    KnownMovieRatingsCount = []

    KnownUserRatings = []
    PredictedUserRatings = []
    KnownUserRatingsCount = []


    # Figuring out the number of cores in this PC
    num_cores = mp.cpu_count()
    print('This computer has', num_cores, 'cores.')

    # Starting a timer to evaluate how long the process lasts
    StartTime = time.time()
    print('--------------------Staritng the process--------------------')

    # 1.1 Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    ClusterMovieIDs = Mine_Cluster_Movie_IDs(DesiredClusterNumber= 1)

    #
    # for CurrentMovieID in ClusterMovieIDs:
    #     # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    #     # MovieRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
    #     CurrentMovieRatings = Mine_Dict_Movie_Ratings(CurrentMovieID, InEpoch= True)
    #
    #     # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
    #     KnownMovieRatings.append(CurrentMovieRatings[1])
    #
    #     # Add up the number of users rating the current movie
    #     KnownMovieRatingsCount.append(len(CurrentMovieRatings[1]))
    #
    #     # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
    #     # for now that will be the simplest appraoch).
    #     # This average reading will be the give for all users regardless.
    #     # Movie Stats are: MovieID, MeanRating, MaxRating, MinRating, MovieStdDev
    #     CurrentMovieStats = GenerateSingleMovieRatingStats(CurrentMovieID)
    #
    #     # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
    #     PredictedMovieRatings.append(CurrentMovieStats[1])               # CurrentMovieMean = CurrentMovieStats[1]
    #
    # print('Known Movie Ratings: ', KnownMovieRatings)
    # print('Predicted Movie Ratings: ', PredictedMovieRatings)
    # print('Number of Known Ratings per movie:', KnownMovieRatingsCount)
    # # Ending the process. Ending Timer
    # ElapsedTime = time.time() - StartTime
    # print('Time elapse: ', ElapsedTime, ' seconds.')
    # print('--------------------Finishing the process--------------------')
    # #


    # Generating the number of ratings for each movie in that cluster. Another alternate is to use Index 3 for Mine_Dict_Movie_Ratings
    KnownMovieRatingsCount = [len(dummy) for dummy in KnownMovieRatings]
    print('Number of Known Ratings per movie:', KnownMovieRatingsCount)



    # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________   
    ClusterMovieIDs = Mine_Cluster_Movie_IDs(DesiredClusterNumber= 1)
    # Look up the ratings for all movie IDs in that particular cluster.
    KnownMovieRatings = [Mine_Dict_Movie_Ratings(CurrentMovieID, InEpoch=True)[1] for CurrentMovieID in ClusterMovieIDs]


    # 2. Mining User IDs in a given cluster label generated from UserIDclusters.csv
    ClusterUserIDs = Mine_Cluster_User_IDs(DesiredClusterNumber= 1)
    # Look up the ratings for all user IDs in that particular cluster.
    KnownUserRatings = [Mine_Dict_User_Ratings(CurrentMovieID, InEpoch=True)[1] for CurrentMovieID in ClusterMovieIDs]
    
    
        #     # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
    #     PredictedMovieRatings.append(CurrentMovieStats[1])
    #
    # # Calling Moving data from Dictionary, and extracting the ratings (index = 1)
    # #
    # KnownMovieRatings.append([Mine_Dict_Movie_Ratings(CurrentMovieID,InEpoch= True)[1] for CurrentMovieID in ClusterMovieIDs])
    # PredictedMovieRatings.append([ for ])
    #
    # print('Length of Known Movies in Cluster', len(*KnownMovieRatings))
    # # print('First trial',KnownMovieRatings)
    # # print('Known Movie Ratings', *KnownMovieRatings)


    # # Flattening the Array
    # KnownMovieRatings = list(itertools.chain(*KnownMovieRatings))
    # print(KnownMovieRatings)
    #
    # # Appending the Actual for all users for each movie.
    # # KnownMovieRatings.append(CurrentMovieRatings[1])
    # # # print(CurrentMovieRatings)
    # # # print(KnownMovieRatings)
    # # # print(len(KnownMovieRatings))
    # Movie Stats are: MovieID, MeanRating, MaxRating, MinRating, MovieStdDev
    # CurrentMovieStats = GenerateSingleMovieRatingStats(CurrentMovieID)
    # CurrentMovieMean = CurrentMovieStats[1]
    # #
    # #
    # # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
    # PredictedMovieRatings.append(CurrentMovieStats[1])

    # # Movie Stats are: MovieID, MeanRating, MaxRating, MinRating, MovieStdDev
    # CurrentMovieStats = [GenerateSingleMovieRatingStats(CurrentMovieID) for CurrentMovieID in ClusterMovieIDs]
    # print('Current movie stats (MovieID, MeanRating, MaxRating, MinRating, MovieStdDev): ', CurrentMovieStats, '\n')
    #
    # # Putting Parallel Processing of tasks on hold for now.
    #
    # ElapsedTime = time.time() - StartTime
    # print('Time elapsed: ', ElapsedTime, ' seconds.')

    # Next step is to generate

    # CurrentClusterRMSE = RMSE_Movies(KnownMovieRatings, PredictedMovieRatings)

        # MovieRatingsMeans(key=CurrentMovieID, value= CurrentMovieMeanRating)
    #
    # MovieRatingsMeans[CurrentMovieID] = np.nanmean(CurrentMovieRatings)

    #
    # # Calculating the cluster mean:
    # print(MovieRatingsMeans)
    #
    # a = MovieRatingsMeans.values()
    # print(a)
    #
    # PredictedMovieRatings = np.nanmean(MovieRatingsMeans.values())
    # print(PredictedMovieRatings)
    #         # 3.b. Calculate an improved *PREDICTED Ratings* based on historical trends over time.
    #         # user that value to predict all the values for all movies combined.
    #
    #         # 3.c. This will build on clustered user data. It will call PNN(MovieID, UserID),
    #         # which is essentially PNN(Movie Cluster Label, User Cluster Label).
    #         # An even improved *PREDICTED Ratings*
    #
    #
    # # 4. Find the actual values from the probe data set:
    #
    # # ProbeUserIDs(ClusterMovieIDs)
    # KnownMovieRatings = Mine_Dict_Movie_Ratings(DesiredMovieID= 2)








'''
